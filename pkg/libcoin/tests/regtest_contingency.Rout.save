
R version 3.3.1 (2016-06-21) -- "Bug in Your Hair"
Copyright (C) 2016 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> ### Regression tests for the r x c x K problem, i.e.,
> ### testing the independence of a factor
> ### `y' and a factor factor `x' (possibly blocked)
> 
> set.seed(290875)
> library("coin")
Loading required package: survival
> library("libcoin")
> 
> isequal <- coin:::isequal
> options(useFancyQuotes = FALSE)
> 
> 
> ### generate data: 2 x 2 x K
> dat <- data.frame(x = gl(2, 50), y = gl(2, 50)[sample(1:100)],
+                   block = gl(10, 10)[sample(1:100)])[sample(1:100, 75),]
> 
> ### Pearsons Chisq Test, asymptotic distribution
> ptwo <- chisq.test(table(dat$x, dat$y), correct = FALSE)$p.value
> 
> stopifnot(isequal(pvalue(lc("chisq_test",y ~ x, data = dat)), ptwo))
[1] TRUE
> stopifnot(isequal(pvalue(lc("chisq_test",table(dat$y, dat$x))), ptwo))
[1] TRUE
> 
> ### Cochran-Mantel-Haenzel Test, asymptotic distribution
> ptwo <- drop(mantelhaen.test(table(dat$x, dat$y, dat$block),
+                              correct = FALSE)$p.value)
> 
> stopifnot(isequal(pvalue(lc("cmh_test",y ~ x | block, data = dat)), ptwo))
[1] TRUE
> stopifnot(isequal(pvalue(lc("cmh_test",table(dat$y, dat$x, dat$block))), ptwo))
[1] TRUE
> 
> 
> ### generate data: r x c x K
> dat <- data.frame(x = gl(4, 25), y = gl(4, 25)[sample(1:100)],
+                   block = gl(2, 50)[sample(1:100)])
> 
> ### Cochran-Mantel-Haenzel Test, asymptotic distribution
> ### (was wrong in R < 2.1.0)
> ptwo <- drop(mantelhaen.test(table(dat$y, dat$x, dat$block),
+                              correct = FALSE)$p.value)
> 
> stopifnot(isequal(pvalue(lc("cmh_test",y ~ x | block, data = dat)), ptwo))
[1] TRUE
> stopifnot(isequal(pvalue(lc("cmh_test",table(dat$y, dat$x, dat$block))), ptwo))
[1] TRUE
> 
> 
> ### generate data: r x c x K
> dat <- data.frame(x = gl(4, 25), y = gl(5, 20)[sample(1:100)],
+                   block = gl(2, 50)[sample(1:100)])
> 
> ### Cochran-Mantel-Haenzel Test, asymptotic distribution
> ### (was wrong in R < 2.1.0)
> ptwo <- drop(mantelhaen.test(table(dat$y, dat$x, dat$block),
+                              correct = FALSE)$p.value)
> 
> stopifnot(isequal(pvalue(lc("cmh_test",y ~ x | block, data = dat)), ptwo))
[1] TRUE
> stopifnot(isequal(pvalue(lc("cmh_test",table(dat$y, dat$x, dat$block))), ptwo))
[1] TRUE
> 
> 
> ### 2x2 table and maxstat
> x <- c(rep(1,51), rep(2,49))
> y <- factor(c(rep(0,49), rep(1,51)))[sample(1:100)]
> stopifnot(isequal(as.vector(statistic(lc("independence_test",table(x, y)))),
+ as.vector(statistic(lc("maxstat_test",y ~ x )))))
[1] TRUE
[1] TRUE
> 
> 
> ### maxstat for multiple, ordered and unordered covariates
> dat <- data.frame(w = rnorm(100), x = runif(100), y = gl(4, 25)[sample(1:100)],
+                   z = ordered(gl(4, 25)[sample(1:100)]))
> 
> mt <- lc("maxstat_test",w ~ x, data = dat)
[1] TRUE
Warning message:
In Test(lev, xtrafo = "id", type = teststat, alternative = alternative) :
  cmvnorm: completion with ERROR > EPS
> mt

	Asymptotic Generalized Maximally Selected Statistics

data:  w by x
maxT = 2.0168, p-value = 0.36
alternative hypothesis: two.sided
sample estimates:
  "best" cutpoint: <= 0.7873206

> est <- mt@estimates$estimate$cutpoint
> stopifnot(isequal(statistic(mt),
+                   abs(statistic(lc("independence_test",w ~ (x <= est), data = dat)))))
[1] TRUE
> 
> mt <- lc("maxstat_test",w ~ y, data = dat)
[1] TRUE
Warning message:
In Test(lev, xtrafo = "id", type = teststat, alternative = alternative) :
  cmvnorm: completion with ERROR > EPS
> mt

	Asymptotic Generalized Maximally Selected Statistics

data:  w by y (1, 2, 3, 4)
maxT = 1.7341, p-value = 0.3193
alternative hypothesis: two.sided
sample estimates:
  "best" cutpoint: {1} vs. {2, 3, 4}

> est <- mt@estimates$estimate$cutpoint
> xx <- dat$y %in% est
> stopifnot(isequal(statistic(mt),
+                   abs(statistic(lc("independence_test",w ~ xx, data = dat)))))
[1] TRUE
> 
> mt <- lc("maxstat_test",w ~ z, data = dat)
[1] TRUE
> mt

	Asymptotic Generalized Maximally Selected Statistics

data:  w by z (1 < 2 < 3 < 4)
maxT = 0.75896, p-value = 0.783
alternative hypothesis: two.sided
sample estimates:
  "best" cutpoint: {1, 2, 3} vs. {4}

> est <- mt@estimates$estimate$cutpoint
> xx <- dat$z %in% est
> stopifnot(isequal(statistic(mt),
+                   abs(statistic(lc("independence_test",w ~ xx, data = dat)))))
[1] TRUE
> 
> mt <- lc("maxstat_test",w ~ x + y + z, data = dat)
[1] TRUE
Warning message:
In Test(lev, xtrafo = "id", type = teststat, alternative = alternative) :
  cmvnorm: completion with ERROR > EPS
> mt

	Asymptotic Generalized Maximally Selected Statistics

data:  w by x, y, z(ordered)
maxT = 2.0168, p-value = 0.5319
alternative hypothesis: two.sided
sample estimates:
  "best" cutpoint: <= 0.7873206
       covariable: x

> est <- mt@estimates$estimate
> xsel <- dat[[est[[1]]]]
> if (is.factor(xsel) && !is.ordered(xsel)) {
+     xx <- xsel %in% est[2]
+ } else {
+     xx <- xsel <= est[2]
+ }
> stopifnot(isequal(statistic(mt),
+                   abs(statistic(lc("independence_test",w ~ xx, data = dat)))))
[1] TRUE
> 
> 
> ### marginal homogeneity
> rating <- c("low", "moderate", "high")
> x <- as.table(matrix(c(20, 10,  5,
+                        3, 30, 15,
+                        0,  5, 40),
+                      ncol = 3, byrow = TRUE,
+                      dimnames = list(Rater1 = rating, Rater2 = rating)))
> ### test statistic W_0 = 13.76
> ### see http://ourworld.compuserve.com/homepages/jsuebersax/mcnemar.htm
> stopifnot(all.equal(round(statistic(lc("mh_test",x)), 2), 13.76))
[1] TRUE
> 
> proc.time()
   user  system elapsed 
  4.428   0.032   4.455 
